<!DOCTYPE html>
<html>
<head>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/showdown/0.3.1/showdown.min.js"></script>
    <style>
        body {
            white-space: pre;
            font-family: Consolas, monospace;
            font-size: 15px;
            margin-left: 20px;
        }
        h1 {
            font-size: 20px;
            margin-top: 0px;
            margin-bottom: 0px;
        }
        p {
            margin-top: 0px;
            margin-bottom: 0px;
        }
        h1 {
            font-size: 30px;
        }
    </style>
</head>
<body>
<h1>CARBON PROGRAMMING LANGUAGE</h1>
<div data-markdown>
# Notation

Production  = production_name "=" [ Expression ]
Expression  = Alternative { "|" Alternative }
Alternative = Term { Term }
Term        = production_name | token [ "..." token ] | Group | Option | Repetition
Group       = "(" Expression ")"
Option      = "[" Expression "]"
Repetition  = "{" Expression "}"

# Source file (ok)

SourceFile = { ImportDecl } { TypeDefn | ModuleDefn | FunctionDefn }

# Digits (ok)

DecimalDigit = "0" ... "9"
BinaryDigit  = "0" | "1"
OctalDigit   = "0" ... "7"
HexDigit     = "0" ... "9" | "A" ... "F" | "a" ... "f"

# Letters (ok)

Letter       = { "A" ... "Z" | "a" ... "z" | "_" }
LittleUValue = "\u" HexDigit HexDigit HexDigit HexDigit
BigUValue    = "\U" HexDigit HexDigit HexDigit HexDigit
                    HexDigit HexDigit HexDigit HexDigit
EscapeChar   = "\" ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | '\' | "'" | '"' )
PrintableASCIIChar = \* Any printable ASCII character *\

# Identifiers

Identifier     = Letter { Letter | DecimalDigit }
IdentifierList = Identifier { "," Identifier }
ModuleName     = Identifier { "." Identifier }
QualifiedIdent = ModuleName "." Identifier
ExpressionList = Expression { "," Expression }

# Integer literals (ok)

IntLit     = DecimalLit | BinaryLit | OctalLit | HexLit
DecimalLit = [ "10x" ] DecimalDigit { DecimalDigit }
BinaryLit  = "2x" BinaryDigit { BinaryDigit }
OctalLit   = "8x" OctalDigit { OctalDigit }
HexLit     = "16x" HexDigit { HexDigit }

# Floating-point literals (ok)

FloatLit = Decimals "." [ Decimals ] [ Exponent ] |
           Decimals Exponent |
           "." Decimals [ Exponent ]
Decimals = DecimalDigit { DecimalDigit }
Exponent = ( "e" | "E" ) [ "+" | "-" ] Decimals

# Imaginary literals (ok)

ImaginaryLit = ( Decimals | FloatLit ) "i"

# Char literals (ok)

CharLit = "'" ( PrintableASCIIChar | EscapeChar ) "'" | "0" ... "255"

# String literals (ok)

StringLit          = RawStringLit | InterStringLit |
                     RawHeredocStrLit | InterHeredocStrLit
RawStringLit       = "r'" { String } "'" | 'r"' { String } '"'
InterStringLit     = "'" { String } "'" | '"' { String } '"'
RawHeredocStrLit   = "r'''" { String } "'''" | 'r"""' { String } '"""'
InterHeredocStrLit = '"""' { String } '"""' | "'''" { String } "'''"
String             = { PrintableASCIIChar | LittleUValue | BigUValue | EscapeChar } ???
FormatSpecifier    = 

# Function Literal (Anonymous function)

FunctionLit = "def" FuncSignature FunctionBody

# Composite Literal

CompositeLit  = LiteralType LiteralValue
LiteralType   = StructType | UnionType | EnumType | OptionType
LiteralValue  = "{" [ ElementList [ "," ] ] "}"
ElementList   = KeyedElement { "," KeyedElement }
KeyedElement  = [ Key ":" ] Element
Key           = FieldName | Expression | LiteralValue
FieldName     = Identifier
Element       = Expression | LiteralValue

# Tuple literal ??

TupleLit = 

# Types (ok)

Type          = [ StorageClass ] [ TypeQualifier ] TypeName
StorageClass  = "register" | "static"
TypeQualifier = "const" | "volatile" | "restrict" | "atomic" | "const" "restrict"
TypeName      = BoolType | CharType | NumericType | TypeAliasName | PointerType |
                ArrayType | StructType | UnionType | EnumType | OptionType | TuppleType | FunctionType

# Boolean type (ok)

BoolType = "bool"

# Character type (ok)

CharType = "char"

# Numeric type (ok)

NumericType = "byte" | "int" | "int8" | "int16" | "int32" | "int64" |
              "uint" | "uint8" | "uint16" | "uint32" | "uint64" |
              "float32" | "float64" | "float128"

# Pointer type (ok)

PointerType = "ptr" : Type

# Array type (ok)

ArrayType    = ArraySimple | ArrayPointer
ArraySimple  = TypeName "[" ArrayLength "]"
ArrayPointer = "ptr" "[" ArrayLength "]" : Type
ArrayLength  = Expression

# Struct type (ok)

StructType = Identifier

# Union type (ok)

UnionType = Identifier

# Enumeration type (ok)

EnumType  = Identifier

# Option type (ok)

OptionType  = Identifier

# Tupple type (ok)

TuppleType = "(" Type [ Identifier ] { "," Type [ Identifier ] } ")"

# Function type (ok)

FunctionType      = FuncSignature
FuncSignature     = FuncParameterList [ "->" FuncResultList ]
FuncParameterList = "(" Type [ Identifier ] { "," Type [ Identifier ] } ")"
FuncResultList    = "(" Type [ Identifier ] { "," Type [ Identifier ] } ")"

# Type definition (ok)

TypeDefn = StructDefn | UnionDefn | EnumDefn | OptionDefn | TypeAlias

# Struct definition (ok)

StructDefn = "type struct" FieldDecl
FieldDecl  = "{" "}" | { Type IdentifierList }

# Union definition (ok)

UnionDefn = "type union" FieldDecl
FieldDecl = "{" "}" | { Type IdentifierList }

# Enumeration definition (ok)

EnumDefn  = "type enum" FieldDecl
FieldDecl = "{" "}" | { Identifier }

# Option definition (ok)

OptionDefn = "type option" FieldDecl
FieldDecl  = "{" "}" | { Type Identifier }

# Function definition (ok)

FunctionDefn = "def" FunctionName FunctionType FunctionBody
FunctionName = Identifier
FunctionBody = Block

# Type Alias

TypeAlias     = TypeAliasName "=" Type
TypeAliasName = Identifier

# Expression (ok) - An expression specifies the computation of a value by applying operators and functions to operands.

Expression  = UnaryOp OperandExpr | OperandExpr BinaryOp OperandExpr
OperandExpr = Expression | PrimaryExpr

# Operators (ok)

BinaryOp  = ArithOp | RelOp | ShiftOp | LogicalOp | BitOp | AssigOp
ArithOp   = "+" | "-" | "*" | "/" | "%"
RelOp     = "==" | "!=" | "<" | "<=" | ">" | ">="
ShiftOp   = ">>" | "<<" | ">>>" | "<<<"
LogicalOp = "||" | "&&"
BitOp     = "&" | "|" | "^" | "&^"
UnaryOp   = "+" | "-" | "!" | "~" | "*" | "@"

# Primary expressions (ok) - Primary expressions are the operands for unary and binary expressions.

PrimaryExpr   = Operand | PrimaryExpr FieldSelector | PrimaryExpr Index | PrimaryExpr Call
FieldSelector = "." Identifier
Index         = "[" Expression "]"
Call          = "(" [ ExpressionList ] ")"

# Operands (ok) - Operands denote the elementary values in an expression.

Operand  = Literal | ConstVarFuncIdent | "(" Expression ")"
Literal  = BasicLit | CompositeLit | FunctionLit
BasicLit = IntLit | FloatLit | ImaginaryLit | CharLit | StringLit
ConstVarFuncIdent = Identifier | QualifiedIdent

# Statements - Statements control execution.

Block = { Statement [ ";" ] } | Block

Statement =	TypeDefn | SimpleStmt |
            ReturnStmt | BreakStmt | ContinueStmt | GotoStmt | LabelStmt | FallthroughStmt |
            IfStmt | SwitchStmt | ForStmt | WhileStmt | DoWhileStmt |
            DeferStmt

SimpleStmt = EmptyStmt | ExpressionStmt | IncDecStmt | AssignStmt | VarDecl

# Empty statements (ok)

EmptyStmt = ""

# Expression statement

ExpressionStmt = Expression

# Increment decrement statement (ok)

IncDecStmt = Expression ( "++" | "--" )

# Assignment statement (ok)

AssignStmt = IdentifierList AssignOp ExpressionList
AssignOp   = [ ArithOp | ShiftOp | LogicalOp ] "="

# Variable declaration (ok)

VarDecl     = Type VarDeclList
VarDeclList = Identifier [ "=" Expression ] { [ "," ] Identifier [ "=" Expression ] }

# Return statement (ok)

ReturnStmt = "return" [ ExpressionList ]

# Break statement (ok)

BreakStmt = "break" [ Label ]

# Continue statement (ok)

ContinueStmt = "continue" [ Label ]

# Goto statement (ok)

GotoStmt = "goto" Label

# Label statement (ok)

LabelStmt = Label ":" Statement
Label     = Identifier

# Fallthrough statement (ok)

FallthroughStmt = "fallthrough"

# If statement (ok)

IfStmt = "if" Expression Block [ "else" ( IfStmt | Block ) ]

# Switch statement (ok)

SwitchStmt = "switch" [ Expression ] CaseClause
CaseClause = SwitchCase ":" Block
SwitchCase = "case" ExpressionList | "default"

# For statement (ok)

ForStmt   = "for" ForClause Block
ForClause = [ InitStmt ] ";" [ Condition ] ";" [ PostStmt ]
InitStmt  = SimpleStmt
Condition = Expression
PostStmt  = SimpleStmt

# While statement (ok)

WhileStmt = "while" Condition Block
Condition = Expression

# Do-while statement (ok)

DoWhileStmt = "do" Block "while" Condition
Condition   = Expression

# Defer statement (ok)

DeferStmt = "defer" Block

# Modules declaration (ok)

ModuleDefn = "module" ModuleName ModuleBody
ModuleName = Identifier { "." Identifier }
ModuleBody = { TypeDefn | VarDecl | FunctionDefn }

# Import declarations (ok)

ImportDecl = "import" [ ModuleName "from" ] ImportPath [ "as" import ]
ImportPath = string_lit


# TODO

Generics
Attributes
Access modifiers
Operator overloading
Struct ... methods
Type methods
Variable arguments
nil
Safe navigation operator
Nullable types

</div>
<script type="text/javascript">
    window.onload=function(){
        // this function is the reverse version of escapeHTML found at 
        // https://github.com/evilstreak/markdown-js/blob/master/src/render_tree.js
        function unescapeHTML( text ) {
            return text.replace( /&amp;/g, "&" )
                       .replace( /&lt;/g, "<" )
                       .replace( /&gt;/g, ">" )
                       .replace( /&quot;/g, "\"" )
                       .replace( /&#39;/g, "'" );
          }
        // based on https://gist.github.com/paulirish/1343518
        (function(){
            [].forEach.call( document.querySelectorAll('[data-markdown]'), function fn(elem){
                elem.innerHTML = (new Showdown.converter()).makeHtml(unescapeHTML(elem.innerHTML));
            });
        }());
    }
</script>
</body>
</html>
